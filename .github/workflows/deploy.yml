# .github/workflows/deploy.yml
name: Deploy Laravel Filament

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Install and configure production environment
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            set -e

            echo 'üöÄ V√©rification et installation de l'\''environnement de production...'

            # Mise √† jour du syst√®me
            sudo apt update

            # Installation de Docker si pas install√©
            if ! command -v docker &> /dev/null; then
              echo 'üê≥ Installation de Docker...'
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo systemctl enable docker
              sudo systemctl start docker
              sudo usermod -aG docker ${{ secrets.SERVER_USER }}
              rm get-docker.sh
            else
              echo '‚úÖ Docker d√©j√† install√©'
            fi

            # Installation de Docker Compose si pas install√©
            if ! command -v docker-compose &> /dev/null; then
              echo 'üîß Installation de Docker Compose...'
              sudo curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            else
              echo '‚úÖ Docker Compose d√©j√† install√©'
            fi

            # Installation de Git si pas install√©
            if ! command -v git &> /dev/null; then
              echo 'üìö Installation de Git...'
              sudo apt install -y git curl
            else
              echo '‚úÖ Git d√©j√† install√©'
            fi

            # Configuration du swap si pas configur√©
            if ! swapon --show | grep -q swapfile; then
              echo 'üíæ Configuration du swap (1Go)...'
              sudo fallocate -l 1G /swapfile || sudo dd if=/dev/zero of=/swapfile bs=1024 count=1048576
              sudo chmod 600 /swapfile
              sudo mkswap /swapfile
              sudo swapon /swapfile
              echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab

              # Optimisation m√©moire
              echo 'vm.swappiness=10' | sudo tee -a /etc/sysctl.conf
              echo 'vm.vfs_cache_pressure=50' | sudo tee -a /etc/sysctl.conf
              sudo sysctl -p
            else
              echo '‚úÖ Swap d√©j√† configur√©'
            fi

            # Configuration du pare-feu
            if ! sudo ufw status | grep -q 'Status: active'; then
              echo 'üî• Configuration du pare-feu...'
              sudo ufw allow OpenSSH
              sudo ufw allow 80/tcp
              sudo ufw allow 443/tcp
              sudo ufw --force enable
            else
              echo '‚úÖ Pare-feu d√©j√† configur√©'
            fi

            echo '‚úÖ Environnement de production pr√™t !'
          "

      - name: Setup project directory and clone repository
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            set -e

            # Cr√©er le r√©pertoire du projet s'il n'existe pas
            if [ ! -d '${{ secrets.PROJECT_PATH }}' ]; then
              echo 'üìÇ Cr√©ation du r√©pertoire du projet...'
              mkdir -p '${{ secrets.PROJECT_PATH }}'
              cd '${{ secrets.PROJECT_PATH }}'

              # Cloner le repository
              echo 'üì• Clonage du repository...'
              git clone https://github.com/${{ github.repository }}.git .
            else
              echo 'üìÇ R√©pertoire du projet existe, mise √† jour...'
              cd '${{ secrets.PROJECT_PATH }}'
              git fetch origin
              git reset --hard origin/main
            fi

            # S'assurer que nous avons les bonnes permissions
            sudo chown -R ${{ secrets.SERVER_USER }}:${{ secrets.SERVER_USER }} '${{ secrets.PROJECT_PATH }}'
          "

      - name: Setup Docker configuration files
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
            set -e
            cd '${{ secrets.PROJECT_PATH }}'

            # Cr√©er le r√©pertoire docker s'il n'existe pas
            mkdir -p docker

            # Cr√©er nginx.conf
            cat > docker/nginx.conf << 'EOF'
  worker_processes 1;
  events {
  worker_connections 512;
}
  http {
  include /etc/nginx/mime.types;
  server {
  listen 80;
  root /var/www/html/public;
  index index.php;
  location / {
  try_files \$uri \$uri/ /index.php?\$query_string;
  }
  location ~ \.php$ {
  fastcgi_pass 127.0.0.1:9000;
  fastcgi_param SCRIPT_FILENAME \$realpath_root\$fastcgi_script_name;
  include fastcgi_params;
  }
}
}
  EOF

  # Cr√©er nginx-ssl.conf
  cat > docker/nginx-ssl.conf << 'EOF'
  worker_processes 1;
  events {
  worker_connections 512;
}
  http {
  include /etc/nginx/mime.types;
  default_type application/octet-stream;
  sendfile on;
  keepalive_timeout 15;
  client_max_body_size 20M;
  gzip on;
  gzip_types text/plain text/css application/json application/javascript text/xml application/xml;

  server {
  listen 80;
  server_name _;
  location /.well-known/acme-challenge/ {
  root /var/www/certbot;
  }
  location / {
  return 301 https://\$host\$request_uri;
  }
}

  server {
  listen 443 ssl http2;
  server_name ${{ secrets.DOMAIN_NAME }};
  root /var/www/html/public;
  index index.php;

  ssl_certificate /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/privkey.pem;
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_session_cache shared:SSL:10m;

  location / {
  try_files \$uri \$uri/ /index.php?\$query_string;
  }

  location ~ \.php$ {
  fastcgi_pass app:9000;
  fastcgi_param SCRIPT_FILENAME \$realpath_root\$fastcgi_script_name;
  include fastcgi_params;
  }

  location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg)$ {
  expires 1y;
  add_header Cache-Control \"public, immutable\";
  }
}
}
  EOF

  # Cr√©er supervisord.conf
  cat > docker/supervisord.conf << 'EOF'
  [supervisord]
  nodaemon=true
  user=root
  logfile=/var/log/supervisor/supervisord.log
  pidfile=/var/run/supervisord.pid

  [program:nginx]
  command=nginx -g \"daemon off;\"
  stdout_logfile=/dev/stdout
  stdout_logfile_maxbytes=0
  stderr_logfile=/dev/stderr
  stderr_logfile_maxbytes=0
  autorestart=false
  startretries=0

  [program:php-fpm]
  command=php-fpm
  stdout_logfile=/dev/stdout
  stdout_logfile_maxbytes=0
  stderr_logfile=/dev/stderr
  stderr_logfile_maxbytes=0
  autorestart=false
  startretries=0
  EOF

  # Cr√©er php-fpm.conf
  cat > docker/php-fpm.conf << 'EOF'
  [www]
  user = www
  group = www
  listen = 9000
  listen.owner = www
  listen.group = www
  pm = dynamic
  pm.max_children = 10
  pm.start_servers = 2
  pm.min_spare_servers = 1
  pm.max_spare_servers = 3
  pm.max_requests = 500
  EOF

  # Cr√©er mysql.cnf
  cat > docker/mysql.cnf << 'EOF'
  [mysqld]
  innodb_buffer_pool_size = 128M
  innodb_log_file_size = 32M
  innodb_flush_log_at_trx_commit = 2
  max_connections = 50
  query_cache_size = 16M
  tmp_table_size = 32M
  max_heap_table_size = 32M
  EOF

  echo '‚úÖ Fichiers de configuration Docker cr√©√©s'
  "

- name: Setup environment and deploy application
  run: |
    ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
      set -e
      cd '${{ secrets.PROJECT_PATH }}'

      # Cr√©ation du fichier .env
      cat > .env << 'EOF'
  APP_NAME=\"Laravel Filament\"
  APP_ENV=production
  APP_KEY=${{ secrets.APP_KEY }}
  APP_DEBUG=false
  APP_URL=https://${{ secrets.DOMAIN_NAME }}

  DB_CONNECTION=mysql
  DB_HOST=mysql
  DB_PORT=3306
  DB_DATABASE=${{ secrets.DB_DATABASE }}
  DB_USERNAME=${{ secrets.DB_USERNAME }}
  DB_PASSWORD=${{ secrets.DB_PASSWORD }}

  DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
  SSL_EMAIL=${{ secrets.SSL_EMAIL }}

  CACHE_DRIVER=file
  QUEUE_CONNECTION=sync
  SESSION_DRIVER=file
  SESSION_LIFETIME=120

  MAIL_MAILER=smtp
  EOF

  # Cr√©er les r√©pertoires n√©cessaires
  mkdir -p storage/app/public
  mkdir -p storage/framework/cache
  mkdir -p storage/framework/sessions
  mkdir -p storage/framework/views
  mkdir -p storage/logs
  mkdir -p bootstrap/cache

  # Arr√™ter les conteneurs existants
  if command -v docker-compose &> /dev/null && [ -f docker-compose.yml ]; then
  docker-compose down || true
  fi

  # Construire et d√©marrer les conteneurs
  echo 'üê≥ Construction et d√©marrage des conteneurs...'
  docker-compose build --no-cache
  docker-compose up -d

  # Attendre que les services soient pr√™ts
  echo '‚è≥ Attente du d√©marrage des services...'
  sleep 45

  # V√©rifier que les conteneurs sont en cours d'ex√©cution
  docker-compose ps

  # Installer les d√©pendances et configurer Laravel
  echo 'üì¶ Installation des d√©pendances Laravel...'
  docker-compose exec -T app composer install --no-dev --optimize-autoloader --no-interaction || true

  # G√©n√©rer la cl√© d'application si n√©cessaire
  docker-compose exec -T app php artisan key:generate --force || true

  # Ex√©cuter les migrations
  echo 'üóÑÔ∏è Ex√©cution des migrations...'
  docker-compose exec -T app php artisan migrate --force || true

  # Optimisations Laravel
  echo '‚ö° Optimisations Laravel...'
  docker-compose exec -T app php artisan config:cache || true
  docker-compose exec -T app php artisan route:cache || true
  docker-compose exec -T app php artisan view:cache || true
  docker-compose exec -T app php artisan storage:link || true

  # Configuration des permissions
  docker-compose exec -T app chown -R www:www /var/www/html/storage || true
  docker-compose exec -T app chown -R www:www /var/www/html/bootstrap/cache || true

  echo '‚úÖ Application d√©ploy√©e avec succ√®s !'
  "

- name: Setup SSL Certificate
  run: |
    ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
      set -e
      cd '${{ secrets.PROJECT_PATH }}'

      # V√©rifier si le certificat SSL existe d√©j√†
      if [ ! -d \"/var/lib/docker/volumes/\$(docker volume ls -q | grep certbot_certs | head -1)/_data/live/${{ secrets.DOMAIN_NAME }}\" ]; then
        echo 'üîí G√©n√©ration du certificat SSL...'

        # Attendre que nginx soit pr√™t
        sleep 10

        # G√©n√©rer le certificat
        docker-compose run --rm certbot || echo 'Erreur lors de la g√©n√©ration du certificat - continuons'

        # Red√©marrer nginx avec la configuration SSL
        sleep 5
        docker-compose restart nginx
      else
        echo '‚úÖ Certificat SSL d√©j√† configur√©'
      fi
    "

- name: Cleanup and verify deployment
  run: |
    ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "
      cd '${{ secrets.PROJECT_PATH }}'

      # Nettoyage Docker
      docker system prune -f || true

      # V√©rifier l'√©tat des conteneurs
      echo 'üìä √âtat des conteneurs :'
      docker-compose ps

      echo '‚úÖ D√©ploiement termin√© !'
    "

- name: Verify website accessibility
  run: |
    echo 'üåê V√©rification de l'\''accessibilit√© du site...'
    sleep 15

    # Test HTTP (doit rediriger vers HTTPS)
    curl -I http://${{ secrets.DOMAIN_NAME }} || echo 'HTTP test failed'

    # Test HTTPS (peut √©chouer si SSL pas encore configur√©)
    curl -I https://${{ secrets.DOMAIN_NAME }} || echo 'HTTPS test failed - normal si premier d√©ploiement'
